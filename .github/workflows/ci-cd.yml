# 🚀 CI/CD Pipeline - Build, Test, and Deploy Multitask Platform
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop, staging]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  GO_VERSION: '1.22'
  NODE_VERSION: '18'
  AWS_REGION: 'us-east-1'

jobs:
  # 🔍 Code Quality and Security
  code-quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: |
            frontend/package-lock.json
            infra/package-lock.json

      - name: Go Mod Download
        run: go mod download

      - name: Install Frontend Dependencies
        run: |
          cd frontend
          npm ci

      - name: Install Infrastructure Dependencies
        run: |
          cd infra
          npm ci

      # Go Code Quality
      - name: Go Vet
        run: go vet ./...

      - name: Go Format Check
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "Code is not formatted properly:"
            gofmt -s -l .
            exit 1
          fi

      - name: Go Lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest
          args: --timeout=5m

      # Frontend Code Quality
      - name: Frontend Lint
        run: |
          cd frontend
          npm run lint

      - name: Frontend Type Check
        run: |
          cd frontend
          npm run type-check

      # Security Scanning
      - name: Go Security Scan
        uses: securecodewarrior/github-action-gosec@master
        with:
          args: './...'

      - name: Frontend Security Audit
        run: |
          cd frontend
          npm audit --audit-level moderate

      # Infrastructure Validation
      - name: Serverless Config Validation
        run: |
          cd infra
          npx serverless print > /dev/null

  # 🧪 Backend Tests
  backend-tests:
    name: Backend Tests
    runs-on: ubuntu-latest
    needs: code-quality
    services:
      # DynamoDB Local for testing
      dynamodb:
        image: amazon/dynamodb-local
        ports:
          - 8000:8000
        options: >-
          --health-cmd "curl -f http://localhost:8000/ || exit 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Go Mod Download
        run: go mod download

      - name: Create Test Tables
        run: |
          # Setup DynamoDB Local tables for testing
          aws dynamodb create-table \
            --endpoint-url http://localhost:8000 \
            --table-name test-auth-sessions \
            --attribute-definitions AttributeName=session_id,AttributeType=S \
            --key-schema AttributeName=session_id,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --no-cli-pager || true

      - name: Run Unit Tests
        env:
          DYNAMODB_ENDPOINT: http://localhost:8000
          JWT_SECRET: test-secret
          STAGE: test
        run: |
          go test -v -race -coverprofile=coverage.out ./...

      - name: Generate Coverage Report
        run: |
          go tool cover -html=coverage.out -o coverage.html

      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
          flags: backend
          name: backend-coverage

      - name: Run Integration Tests
        env:
          DYNAMODB_ENDPOINT: http://localhost:8000
          JWT_SECRET: test-secret
          STAGE: test
        run: |
          go test -v -tags=integration ./...

      - name: Benchmark Tests
        run: |
          go test -bench=. -benchmem ./... > benchmark.txt

      - name: Upload Test Artifacts
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: backend-test-results
          path: |
            coverage.html
            benchmark.txt

  # 🎨 Frontend Tests
  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest
    needs: code-quality
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Dependencies
        run: |
          cd frontend
          npm ci

      - name: Run Unit Tests
        run: |
          cd frontend
          npm run test -- --coverage --watchAll=false

      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./frontend/coverage/lcov.info
          flags: frontend
          name: frontend-coverage

      - name: Build Frontend
        run: |
          cd frontend
          npm run build

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: frontend-build
          path: frontend/dist

  # 🔨 Build Services
  build-services:
    name: Build Go Services
    runs-on: ubuntu-latest
    needs: [backend-tests]
    strategy:
      matrix:
        service: [auth, profile, chat, post, catalog, ai]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Go Mod Download
        run: go mod download

      - name: Build Service
        env:
          CGO_ENABLED: 0
          GOOS: linux
          GOARCH: amd64
        run: |
          mkdir -p bin
          cd services/${{ matrix.service }}-svc
          go build -ldflags="-s -w" -o ../../bin/${{ matrix.service }} ./cmd/main.go

      - name: Upload Service Binary
        uses: actions/upload-artifact@v3
        with:
          name: service-${{ matrix.service }}
          path: bin/${{ matrix.service }}

  # 🚀 Deploy to Development
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [frontend-tests, build-services]
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    environment: development
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: infra/package-lock.json

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Service Binaries
        uses: actions/download-artifact@v3
        with:
          name: service-auth
          path: bin/
      
      - name: Download Service Binaries
        uses: actions/download-artifact@v3
        with:
          name: service-profile
          path: bin/

      - name: Download Service Binaries
        uses: actions/download-artifact@v3
        with:
          name: service-chat
          path: bin/

      - name: Download Service Binaries
        uses: actions/download-artifact@v3
        with:
          name: service-post
          path: bin/

      - name: Download Service Binaries
        uses: actions/download-artifact@v3
        with:
          name: service-catalog
          path: bin/

      - name: Download Service Binaries
        uses: actions/download-artifact@v3
        with:
          name: service-ai
          path: bin/

      - name: Make Binaries Executable
        run: chmod +x bin/*

      - name: Install Infrastructure Dependencies
        run: |
          cd infra
          npm ci

      - name: Deploy Infrastructure
        run: |
          cd infra
          npx serverless deploy --stage dev --verbose
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Download Frontend Build
        uses: actions/download-artifact@v3
        with:
          name: frontend-build
          path: frontend/dist

      - name: Deploy Frontend to S3
        run: |
          aws s3 sync frontend/dist/ s3://multitask-frontend-dev --delete

      - name: Invalidate CloudFront
        run: |
          DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --stack-name multitask-platform-dev \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendCloudFrontDistribution`].OutputValue' \
            --output text)
          aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*"

      - name: Run Smoke Tests
        run: |
          # Wait for deployment to be ready
          sleep 30
          
          # Get API Gateway URL
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name multitask-platform-dev \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayRestApiUrl`].OutputValue' \
            --output text)
          
          # Health check
          curl -f "$API_URL/v1/auth/health" || exit 1
          echo "✅ Development deployment successful!"

  # 🎯 Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [frontend-tests, build-services]
    if: github.ref == 'refs/heads/staging' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: infra/package-lock.json

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download All Service Binaries
        uses: actions/download-artifact@v3
        with:
          pattern: service-*
          path: bin/
          merge-multiple: true

      - name: Make Binaries Executable
        run: chmod +x bin/*

      - name: Install Infrastructure Dependencies
        run: |
          cd infra
          npm ci

      - name: Deploy Infrastructure
        run: |
          cd infra
          npx serverless deploy --stage staging --verbose
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Download Frontend Build
        uses: actions/download-artifact@v3
        with:
          name: frontend-build
          path: frontend/dist

      - name: Deploy Frontend to S3
        run: |
          aws s3 sync frontend/dist/ s3://multitask-frontend-staging --delete

      - name: Invalidate CloudFront
        run: |
          DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --stack-name multitask-platform-staging \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendCloudFrontDistribution`].OutputValue' \
            --output text)
          aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*"

      - name: Run E2E Tests
        run: |
          # Wait for deployment to be ready
          sleep 60
          
          # Get API Gateway URL
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name multitask-platform-staging \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayRestApiUrl`].OutputValue' \
            --output text)
          
          # Comprehensive health checks
          curl -f "$API_URL/v1/auth/health" || exit 1
          echo "✅ Staging deployment successful!"

  # 🌟 Deploy to Production
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [frontend-tests, build-services]
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod')
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: infra/package-lock.json

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download All Service Binaries
        uses: actions/download-artifact@v3
        with:
          pattern: service-*
          path: bin/
          merge-multiple: true

      - name: Make Binaries Executable
        run: chmod +x bin/*

      - name: Install Infrastructure Dependencies
        run: |
          cd infra
          npm ci

      - name: Deploy Infrastructure
        run: |
          cd infra
          npx serverless deploy --stage prod --verbose
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}

      - name: Download Frontend Build
        uses: actions/download-artifact@v3
        with:
          name: frontend-build
          path: frontend/dist

      - name: Deploy Frontend to S3
        run: |
          aws s3 sync frontend/dist/ s3://multitask-frontend-prod --delete

      - name: Invalidate CloudFront
        run: |
          DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --stack-name multitask-platform-prod \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendCloudFrontDistribution`].OutputValue' \
            --output text)
          aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*"

      - name: Production Health Check
        run: |
          # Wait for deployment to be ready
          sleep 90
          
          # Get API Gateway URL
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name multitask-platform-prod \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayRestApiUrl`].OutputValue' \
            --output text)
          
          # Production health checks
          curl -f "$API_URL/v1/auth/health" || exit 1
          echo "🚀 Production deployment successful!"

      - name: Create GitHub Release
        if: github.ref == 'refs/heads/main'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Release v${{ github.run_number }}
          body: |
            ## 🚀 Production Release v${{ github.run_number }}
            
            ### Changes
            ${{ github.event.head_commit.message }}
            
            ### Deployment Info
            - **Commit**: ${{ github.sha }}
            - **Branch**: ${{ github.ref_name }}
            - **Deploy Time**: ${{ github.event.head_commit.timestamp }}
            
            ### Health Check
            ✅ All services deployed and healthy
          draft: false
          prerelease: false

  # 📊 Post-Deployment Monitoring
  post-deployment:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-dev, deploy-staging, deploy-prod]
    if: always() && (needs.deploy-dev.result == 'success' || needs.deploy-staging.result == 'success' || needs.deploy-prod.result == 'success')
    steps:
      - name: Setup Monitoring
        run: |
          # Set up CloudWatch alarms, monitoring dashboards, etc.
          echo "Setting up post-deployment monitoring..."
          
      - name: Slack Notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          text: |
            🚀 Multitask Platform Deployment Update
            
            **Status**: ${{ job.status }}
            **Branch**: ${{ github.ref_name }}
            **Commit**: ${{ github.sha }}
            **Run**: ${{ github.run_number }}
            
            View details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

# 📝 Workflow Summary
# This CI/CD pipeline provides:
# ✅ Comprehensive code quality checks
# ✅ Security scanning for all components
# ✅ Automated testing (unit, integration, e2e)
# ✅ Multi-environment deployments (dev, staging, prod)
# ✅ Infrastructure as Code deployment
# ✅ Frontend and backend artifact management
# ✅ Health checks and monitoring
# ✅ Slack notifications and GitHub releases
# ✅ Rollback capabilities (manual trigger)